<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tetris - Hir Games</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <style>
    :root {
      --bg-top: #2f2a8f;
      --bg-bottom: #050517;
      --shell: #dedede;
      --shell-border: #a0a0a0;
      --panel-dark: #2b2b2b;
      --panel-border: #707070;
      --label-text: #efefef;
      --screen-text: #e5e7eb;
      --accent-yellow: #facc15;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom));
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f9fafb;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      touch-action: none;
    }

    .frame {
      width: 100%;
      max-width: 960px;
      padding: 6px;
      display: flex;
      justify-content: center;
    }

    .cabinet {
      /* side columns tiny → center big */
      width: min(580px, 100vw - 8px);
      display: grid;
      grid-template-columns: 0.14fr 0.72fr 0.14fr;
      gap: 4px;
      padding: 8px;
      border-radius: 22px;
      background: linear-gradient(180deg, var(--shell) 0%, #f5f5f5 40%, #d0d0d0 100%);
      border: 4px solid var(--shell-border);
      box-shadow:
        0 24px 50px rgba(15, 23, 42, 0.85),
        inset 0 0 0 2px rgba(255, 255, 255, 0.7);
    }

    .side-column {
      display: flex;
      flex-direction: column;
      gap: 4px;
      justify-content: center;
    }

    .side-panel {
      min-width: 58px;
      background: linear-gradient(180deg, #efefef 0%, #cfcfcf 100%);
      border-radius: 11px;
      padding: 3px 3px 5px;
      border: 2px solid var(--panel-border);
      box-shadow:
        inset 0 0 0 1px rgba(255, 255, 255, 0.7),
        0 3px 10px rgba(15, 23, 42, .4);
      text-align: center;
    }

    .side-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: .14em;
      color: #111827;
      margin-bottom: 2px;
    }

    .side-screen {
      background: var(--panel-dark);
      color: var(--label-text);
      border-radius: 8px;
      padding: 3px;
      min-height: 26px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: "Courier New", monospace;
      font-size: 9px;
      box-shadow:
        inset 0 0 6px rgba(0,0,0,.8),
        inset 0 0 0 1px rgba(148,163,184,.7);
    }

    .side-stat-col {
      display: flex;
      flex-direction: column;
      gap: 2px;
      width: 100%;
    }

    .side-stat {
      background: var(--panel-dark);
      border-radius: 6px;
      padding: 2px 3px;
      font-family: "Courier New", monospace;
      font-size: 9px;
      text-align: left;
      box-shadow:
        inset 0 0 6px rgba(0,0,0,.8),
        inset 0 0 0 1px rgba(148,163,184,.7);
    }

    .side-stat span {
      float: right;
      font-weight: 700;
      color: var(--accent-yellow);
    }

    .tower {
      background: linear-gradient(180deg, #f4f4f4 0%, #d0d0d0 60%, #bdbdbd 100%);
      border-radius: 20px;
      padding: 6px 5px 7px;
      border: 3px solid var(--shell-border);
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,.7),
        0 4px 10px rgba(15,23,42,.4);
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    .tower-top {
      background: #3f3f3f;
      border-radius: 12px 12px 0 0;
      padding: 3px 6px;
      border: 2px solid #1f2937;
      border-bottom: none;
      box-shadow:
        inset 0 0 0 1px rgba(156,163,175,.7),
        0 3px 8px rgba(0,0,0,.6);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .tower-title {
      font-family: "Courier New", monospace;
      text-transform: uppercase;
      letter-spacing: .18em;
      font-size: 10px;
      color: #f9fafb;
    }

    .tower-score-box {
      background: #111827;
      border-radius: 8px;
      padding: 1px 5px;
      font-family: "Courier New", monospace;
      font-size: 9px;
      color: var(--screen-text);
      box-shadow:
        inset 0 0 8px rgba(0,0,0,.9),
        inset 0 0 0 1px rgba(148,163,184,.7);
    }

    #scoreTop {
      font-weight: 700;
      color: var(--accent-yellow);
      margin-left: 3px;
    }

    .pause-button {
      width: 22px;
      height: 18px;
      border-radius: 7px;
      border: none;
      margin-left: 4px;
      background: linear-gradient(180deg, #d1d5db 0%, #6b7280 100%);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.8),
        0 3px 8px rgba(0,0,0,.6);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .pause-bars {
      width: 9px;
      height: 10px;
      display: flex;
      justify-content: space-between;
    }
    .pause-bars span {
      width: 3px;
      border-radius: 999px;
      background: #111827;
    }

    .tower-inner {
      background: #101010;
      border-radius: 0 0 14px 14px;
      border: 2px solid #1f2937;
      border-top: none;
      padding: 4px;
      box-shadow:
        inset 0 0 20px rgba(0,0,0,1),
        inset 0 0 0 1px rgba(75,85,99,.9);
    }

    .well-wrap {
      background: #000;
      border-radius: 7px;
      padding: 3px;
      border: 1px solid #374151;
      box-shadow:
        inset 0 0 10px rgba(0,0,0,.9);
    }

    #tetris {
      display: block;
      width: 100%;
      height: auto;
      background: #000;
      touch-action: none;
    }

    #nextCanvas, #holdCanvas {
      width: 50px;
      height: 42px;
    }

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.65);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    .hidden { display: none; }

    .modal {
      max-width: 320px;
      width: 90%;
      border-radius: 18px;
      background: linear-gradient(180deg, #4b4b4b 0%, #222 100%);
      border: 3px solid #111;
      box-shadow:
        0 18px 40px rgba(0,0,0,.9),
        inset 0 0 0 1px rgba(156,163,175,.8);
      padding: 12px 14px 14px;
      color: #f9fafb;
      text-align: center;
      font-size: 13px;
    }

    .modal-title {
      font-size: 15px;
      letter-spacing: .16em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .modal-hint {
      margin-top: 8px;
      font-size: 11px;
      text-align: left;
      line-height: 1.4;
      color: #e5e7eb;
    }

    .modal-hint strong {
      color: var(--accent-yellow);
    }

    .modal-btn-row {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 6px 16px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: .08em;
      cursor: pointer;
      box-shadow:
        0 4px 0 rgba(0,0,0,.9),
        0 10px 20px rgba(0,0,0,.9);
    }

    .btn-primary {
      background: linear-gradient(180deg, #34d399 0%, #059669 100%);
      color: #022c22;
    }

    .btn-danger {
      background: linear-gradient(180deg, #f97373 0%, #dc2626 100%);
      color: #111827;
    }

    /* START overlay (leaderboards) */
    .lb-columns {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
      font-size: 11px;
      text-align: left;
    }
    .lb-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: .12em;
      margin-bottom: 4px;
    }
    .lb-list {
      max-height: 150px;
      overflow: auto;
      padding: 4px 6px;
      background: rgba(0,0,0,0.35);
      border-radius: 8px;
    }
    .lb-item {
      display: flex;
      justify-content: space-between;
      padding: 1px 0;
    }

    .frame {
  width: 100%;
  height: 100%;
  padding: 4px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.cabinet {
  width: min(620px, 100vw - 8px);
  display: grid;
  grid-template-columns: 0.14fr 0.72fr 0.14fr;
  gap: 4px;
  padding: 8px;
  border-radius: 22px;
  background: linear-gradient(180deg, var(--shell) 0%, #f5f5f5 40%, #d0d0d0 100%);
  border: 4px solid var(--shell-border);
  box-shadow:
    0 24px 50px rgba(15, 23, 42, 0.85),
    inset 0 0 0 2px rgba(255, 255, 255, 0.7);
}

/* MOBILE: hide side boxes and let center tower take full width */
@media (max-width: 700px) {
  .cabinet {
    width: 100vw;
    height: 100vh;
    padding: 0;
    border-radius: 0;
    border: none;
    box-shadow: none;
    background: none;
    grid-template-columns: 1fr;  /* only center column */
    align-items: center;
    justify-items: center;
  }

  .side-column {
    display: none;
  }

  .tower {
    width: 100vw;
    max-width: 100vw;
    height: 100vh;
    max-height: 100vh;
    border-radius: 0;
    border: none;
    box-shadow: none;
    padding: 6px 8px 10px;
  }

  .tower-inner {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 4px 0 8px;
  }

  .well-wrap {
    flex: 1;
    border-radius: 10px;
  }
}

  </style>
</head>
<body>
<div class="frame">
  <div class="cabinet">
    <!-- LEFT SIDE -->
    <div class="side-column">
      <div class="side-panel">
        <div class="side-label">Hold</div>
        <div class="side-screen">
          <canvas id="holdCanvas" width="50" height="42"></canvas>
        </div>
      </div>
      <div class="side-panel">
        <div class="side-label">Stats</div>
        <div class="side-screen side-stat-col">
          <div class="side-stat">LEVEL <span id="level">1</span></div>
          <div class="side-stat">LINES <span id="lines">0</span></div>
        </div>
      </div>
    </div>

    <!-- CENTER -->
    <div class="tower">
      <div class="tower-top">
        <div class="tower-title">tetris</div>
        <div style="display:flex;align-items:center;gap:4px;">
          <div class="tower-score-box">
            SCORE <span id="scoreTop">0</span>
          </div>
          <button class="pause-button" id="pauseBtn">
            <div class="pause-bars"><span></span><span></span></div>
          </button>
        </div>
      </div>
      <div class="tower-inner">
        <div class="well-wrap">
          <canvas id="tetris"></canvas>
        </div>
      </div>
    </div>

    <!-- RIGHT SIDE -->
    <div class="side-column">
      <div class="side-panel">
        <div class="side-label">Next</div>
        <div class="side-screen">
          <canvas id="nextCanvas" width="50" height="42"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- START OVERLAY: leaderboards + Play -->
<div class="overlay" id="startOverlay">
  <div class="modal">
    <div class="modal-title">Tetris</div>
    <div>Top players</div>
    <div class="lb-columns">
      <div>
        <div class="lb-title">Global</div>
        <div class="lb-list" id="lbGlobal"></div>
      </div>
      <div>
        <div class="lb-title">This chat</div>
        <div class="lb-list" id="lbChat"></div>
      </div>
    </div>
    <div class="modal-btn-row">
      <button class="btn btn-primary" id="btnStartGame">Play</button>
    </div>
    <div class="modal-hint">
      <strong>Controls:</strong><br>
      • Swipe left / right: move<br>
      • Swipe down slowly: soft drop<br>
      • Swipe down fast: hard drop<br>
      • Swipe up: Hold / swap piece<br>
      • Tap: rotate<br>
      • Keyboard: arrows + Space (desktop)
    </div>
  </div>
</div>

<!-- PAUSE MENU -->
<div class="overlay hidden" id="pauseOverlay">
  <div class="modal">
    <div class="modal-title">Paused</div>
    <div>Game is paused.</div>
    <div class="modal-btn-row">
      <button class="btn btn-primary" id="btnResume">Resume</button>
      <button class="btn btn-danger" id="btnQuit">Quit</button>
    </div>
  </div>
</div>

<script>
  const USER_ID = parseInt("{{ user_id|default:'0' }}") || 0;
  const CHAT_ID = parseInt("{{ chat_id|default:'0' }}") || 0;
  const USERNAME = "{{ username|default:'' }}";
  const MESSAGE_ID = parseInt("{{ message_id|default:'0' }}") || 0;
  const INLINE_MESSAGE_ID = "{{ inline_message_id|default:'' }}";

  const canvas = document.getElementById("tetris");
  const ctx = canvas.getContext("2d");
  const nextCanvas = document.getElementById("nextCanvas");
  const nextCtx = nextCanvas.getContext("2d");
  const holdCanvas = document.getElementById("holdCanvas");
  const holdCtx = holdCanvas.getContext("2d");

  const COLS = 10;
  const ROWS = 20;
  let BLOCK = 10;

function resizeCanvas() {
  const isMobile = window.innerWidth <= 700;

  if (isMobile) {
    // Take almost full screen on phones
    const padding = 10;
    const maxW = window.innerWidth - padding;
    const maxH = window.innerHeight - 100; // leave a bit for top bar / chrome

    // 10x20 grid → height = 2 * width, so limit by height
    const width = Math.min(maxW, maxH / 2);
    const height = width * 2;

    canvas.width = width;
    canvas.height = height;
  } else {
    // Desktop / tablet – center, but nice and big
    const w = canvas.parentElement.clientWidth - 10;
    const width = Math.max(220, Math.min(w, 360));
    const height = width * 2;
    canvas.width = width;
    canvas.height = height;
  }

  BLOCK = canvas.width / COLS;
}

  resizeCanvas();
  window.addEventListener("resize", () => {
    resizeCanvas();
    if (board) board.draw();
  });

  const COLORS = [
    null,
    "#00f0f0", "#0000f0", "#f0a000", "#f0f000",
    "#00f000", "#f00000", "#a000f0",
  ];
  const SHAPES = {
    I: [[1,1,1,1]],
    J: [[2,0,0],[2,2,2]],
    L: [[0,0,3],[3,3,3]],
    O: [[4,4],[4,4]],
    S: [[0,5,5],[5,5,0]],
    Z: [[6,6,0],[0,6,6]],
    T: [[0,7,0],[7,7,7]],
  };
  const SHAPE_KEYS = Object.keys(SHAPES);
  function randomShapeMatrix(){return SHAPES[SHAPE_KEYS[(Math.random()*SHAPE_KEYS.length)|0]];}
  function cloneMatrix(m){return m.map(r=>[...r]);}
  function createMatrix(w,h){const m=[];while(h--)m.push(new Array(w).fill(0));return m;}
  function rotate(matrix,dir){
    const res = matrix[0].map((_,i)=>matrix.map(r=>r[i]));
    return dir>0 ? res.map(r=>r.reverse()) : res.reverse();
  }

  class Piece {
    constructor(board, matrix){
      this.board = board;
      this.matrix = cloneMatrix(matrix);
      this.pos = {
        x: (COLS/2|0)-(this.matrix[0].length/2|0),
        y: 0,
      };
    }
    move(dx,dy){
      this.pos.x += dx;
      this.pos.y += dy;
      if (this.board.collides(this)){
        this.pos.x -= dx;
        this.pos.y -= dy;
        return false;
      }
      return true;
    }
    rotate(dir){
      const old = this.matrix;
      this.matrix = rotate(this.matrix, dir);
      const offs = [0,-1,1,-2,2];
      let i=0;
      while(this.board.collides(this)){
        this.pos.x += offs[i];
        i++;
        if (i>offs.length){
          this.matrix = old;
          return;
        }
      }
    }
  }

  class Board {
    constructor(){
      this.matrix = createMatrix(COLS, ROWS);
      this.nextShape = randomShapeMatrix();
      this.holdShape = null;
      this.holdUsed = false;
      this.spawnFromNext();
      this.score = 0;
      this.lines = 0;
      this.level = 1;
      this.dropInterval = 650;
      this.dropCounter = 0;
      this.lastTime = 0;
      this.gameOver = false;
      this.paused = false;
      this.updateHUD();
      this.drawNext();
      this.drawHold();
    }

    spawnFromNext(){
      this.piece = new Piece(this, this.nextShape);
      this.nextShape = randomShapeMatrix();
      this.drawNext();
    }

    hold(){
      if (this.paused || this.gameOver) return;
      if (this.holdUsed) return;
      this.holdUsed = true;

      if (!this.holdShape){
        this.holdShape = cloneMatrix(this.piece.matrix);
        this.spawnFromNext();
      } else {
        const tmp = cloneMatrix(this.holdShape);
        this.holdShape = cloneMatrix(this.piece.matrix);
        this.piece = new Piece(this, tmp);
      }
      this.drawHold();
      if (this.collides(this.piece)){
        this.gameOver = true;
        this.sendScore();
      }
    }

    drawHold(){
      holdCtx.clearRect(0,0,holdCanvas.width,holdCanvas.height);
      if (!this.holdShape) return;
      const m = cloneMatrix(this.holdShape);
      const rows = m.length, cols = m[0].length;
      const cell = Math.min(
        (holdCanvas.width-6)/cols,
        (holdCanvas.height-6)/rows
      );
      const ox = (holdCanvas.width-cols*cell)/2;
      const oy = (holdCanvas.height-rows*cell)/2;
      for (let y=0;y<rows;y++){
        for (let x=0;x<cols;x++){
          const v=m[y][x]; if(!v)continue;
          const px=ox+x*cell, py=oy+y*cell;
          holdCtx.fillStyle = COLORS[v] || "#e5e7eb";
          holdCtx.fillRect(px+0.5,py+0.5,cell-1,cell-1);
          const g=holdCtx.createLinearGradient(px,py,px,py+cell);
          g.addColorStop(0,"rgba(255,255,255,0.4)");
          g.addColorStop(0.4,"rgba(255,255,255,0)");
          g.addColorStop(1,"rgba(0,0,0,0.5)");
          holdCtx.fillStyle=g;
          holdCtx.fillRect(px+0.5,py+0.5,cell-1,cell-1);
        }
      }
    }

    drawNext(){
      nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
      const m = cloneMatrix(this.nextShape);
      const rows = m.length, cols = m[0].length;
      const cell = Math.min(
        (nextCanvas.width-6)/cols,
        (nextCanvas.height-6)/rows
      );
      const ox = (nextCanvas.width-cols*cell)/2;
      const oy = (nextCanvas.height-rows*cell)/2;
      for (let y=0;y<rows;y++){
        for (let x=0;x<cols;x++){
          const v=m[y][x]; if(!v)continue;
          const px=ox+x*cell, py=oy+y*cell;
          nextCtx.fillStyle = COLORS[v] || "#e5e7eb";
          nextCtx.fillRect(px+0.5,py+0.5,cell-1,cell-1);
          const g=nextCtx.createLinearGradient(px,py,px,py+cell);
          g.addColorStop(0,"rgba(255,255,255,0.4)");
          g.addColorStop(0.4,"rgba(255,255,255,0)");
          g.addColorStop(1,"rgba(0,0,0,0.5)");
          nextCtx.fillStyle=g;
          nextCtx.fillRect(px+0.5,py+0.5,cell-1,cell-1);
        }
      }
    }

    updateHUD(){
      document.getElementById("scoreTop").innerText = this.score;
      document.getElementById("lines").innerText = this.lines;
      document.getElementById("level").innerText = this.level;
    }

    collides(piece){
      const m=piece.matrix, o=piece.pos;
      for (let y=0;y<m.length;y++){
        for (let x=0;x<m[y].length;x++){
          if (m[y][x]!==0){
            const nx=x+o.x, ny=y+o.y;
            if (nx<0||nx>=COLS||ny<0||ny>=ROWS) return true;
            if (this.matrix[ny][nx]!==0) return true;
          }
        }
      }
      return false;
    }

    merge(piece){
      piece.matrix.forEach((row,y)=>{
        row.forEach((v,x)=>{
          if(v) this.matrix[y+piece.pos.y][x+piece.pos.x]=v;
        });
      });
    }

    sweep(){
      let cleared=0;
      outer: for (let y=ROWS-1;y>=0;y--){
        for (let x=0;x<COLS;x++){
          if (!this.matrix[y][x]) continue outer;
        }
        const row=this.matrix.splice(y,1)[0].fill(0);
        this.matrix.unshift(row);
        y++; cleared++;
      }
      if(cleared){
        const pts=[0,40,100,300,1200][cleared]||0;
        this.score += pts*this.level;
        this.lines += cleared;
        this.level = 1 + Math.floor(this.lines/10);
        this.dropInterval = Math.max(120,650-(this.level-1)*40);
        this.updateHUD();
      }
    }

    hardDrop(){
      if (this.gameOver||this.paused) return;
      while(this.piece.move(0,1)){}
      this.lockPiece();
    }

    softDropStep(){
      if (this.gameOver||this.paused) return;
      if (!this.piece.move(0,1)) this.lockPiece();
    }

    lockPiece(){
      this.merge(this.piece);
      this.sweep();
      this.holdUsed = false;
      this.spawnFromNext();
      if (this.collides(this.piece)){
        this.gameOver = true;
        this.sendScore();
      }
    }

    update(dt){
      if (this.gameOver||this.paused) return;
      this.dropCounter += dt;
      if (this.dropCounter > this.dropInterval){
        this.softDropStep();
        this.dropCounter = 0;
      }
    }

    draw(){
      ctx.fillStyle="#000";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.strokeStyle="rgba(55,65,81,0.4)";
      ctx.lineWidth=0.5;
      for(let x=0;x<=COLS;x++){
        const px=x*BLOCK+0.5;
        ctx.beginPath();ctx.moveTo(px,0);ctx.lineTo(px,canvas.height);ctx.stroke();
      }
      for(let y=0;y<=ROWS;y++){
        const py=y*BLOCK+0.5;
        ctx.beginPath();ctx.moveTo(0,py);ctx.lineTo(canvas.width,py);ctx.stroke();
      }

      this.drawMatrix(this.matrix,{x:0,y:0});

      const ghostPos={x:this.piece.pos.x,y:this.piece.pos.y};
      while(!this.collides({matrix:this.piece.matrix,pos:{x:ghostPos.x,y:ghostPos.y+1}})){
        ghostPos.y++;
      }
      this.drawMatrixGhost(this.piece.matrix, ghostPos);
      this.drawMatrix(this.piece.matrix,this.piece.pos);
    }

    drawMatrix(matrix,offset){
      matrix.forEach((row,y)=>{
        row.forEach((v,x)=>{
          if(v){
            const px=(x+offset.x)*BLOCK;
            const py=(y+offset.y)*BLOCK;
            ctx.fillStyle = COLORS[v] || "#e5e7eb";
            ctx.fillRect(px+0.5,py+0.5,BLOCK-1,BLOCK-1);
            const g=ctx.createLinearGradient(px,py,px,py+BLOCK);
            g.addColorStop(0,"rgba(255,255,255,0.4)");
            g.addColorStop(0.4,"rgba(255,255,255,0)");
            g.addColorStop(1,"rgba(0,0,0,0.5)");
            ctx.fillStyle=g;
            ctx.fillRect(px+0.5,py+0.5,BLOCK-1,BLOCK-1);
          }
        });
      });
    }

    drawMatrixGhost(matrix,offset){
      ctx.fillStyle="rgba(148,163,184,0.35)";
      matrix.forEach((row,y)=>{
        row.forEach((v,x)=>{
          if(v){
            const px=(x+offset.x)*BLOCK;
            const py=(y+offset.y)*BLOCK;
            ctx.fillRect(px+1,py+1,BLOCK-2,BLOCK-2);
          }
        });
      });
    }

async sendScore() {
  if (!USER_ID) {
    console.warn("sendScore: USER_ID is 0 — not sending");
    return;
  }

  const payload = {
    user_id: USER_ID,
    chat_id: CHAT_ID,
    username: USERNAME,
    score: this.score,
    message_id: MESSAGE_ID,
    inline_message_id: INLINE_MESSAGE_ID,
  };

  console.log("sendScore payload:", payload);

  try {
    const res = await fetch("/games/tetris/submit-score/", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(payload),
    });

    console.log("submit-score status:", res.status);

    if (!res.ok) {
      const text = await res.text();
      console.error("submit-score failed:", text);
    }
  } catch (e) {
    console.error("submit-score error:", e);
  }
}


  }

  let board = new Board();

  function loop(time=0){
    const dt = time - board.lastTime;
    board.lastTime = time;
    board.update(dt);
    board.draw();
    requestAnimationFrame(loop);
  }
  loop();

  // keyboard
  document.addEventListener("keydown", e=>{
    if(board.gameOver||board.paused) return;
    if(e.key==="ArrowLeft") board.piece.move(-1,0);
    else if(e.key==="ArrowRight") board.piece.move(1,0);
    else if(e.key==="ArrowDown") board.softDropStep();
    else if(e.key==="ArrowUp") board.piece.rotate(1);
    else if(e.code==="Space"){e.preventDefault();board.hardDrop();}
    else if(e.key==="Escape") openPause();
  });

  // touch – drag left/right, swipe down / up, tap rotate
  let touchActive=false,startX=0,startY=0,startTime=0,dragLastX=0;

  canvas.addEventListener("touchstart", e=>{
    if(board.gameOver) return;
    const t=e.touches[0];
    const r=canvas.getBoundingClientRect();
    startX=t.clientX-r.left;
    startY=t.clientY-r.top;
    dragLastX = startX;
    startTime=performance.now();
    touchActive=true;
    e.preventDefault();
  });

  canvas.addEventListener("touchmove", e=>{
    if(!touchActive || board.gameOver) return;
    const t=e.touches[0];
    const r=canvas.getBoundingClientRect();
    const x=t.clientX-r.left;
    const dx = x - dragLastX;
    const stepX = BLOCK * 0.6;

    if (dx > stepX) {
      let steps = Math.floor(dx / stepX);
      while (steps-- > 0) board.piece.move(1,0);
      dragLastX = x;
    } else if (dx < -stepX) {
      let steps = Math.floor(-dx / stepX);
      while (steps-- > 0) board.piece.move(-1,0);
      dragLastX = x;
    }

    e.preventDefault();
  });

  canvas.addEventListener("touchend", e=>{
    if(!touchActive || board.gameOver) return;
    touchActive=false;

    const r=canvas.getBoundingClientRect();
    const t=e.changedTouches[0];
    const x=t.clientX-r.left;
    const y=t.clientY-r.top;
    const dx=x-startX;
    const dy=y-startY;
    const dt=performance.now()-startTime;

    const absX=Math.abs(dx), absY=Math.abs(dy);

    if(absY>absX && dy<-22){
      board.hold();
    } else if(absY>absX && dy>18){
      const speed = dy/dt;
      if(speed>0.8 && dy>45) board.hardDrop();
      else board.softDropStep();
    } else if(absX>absY && absX>10){
      // already moved during drag
    } else {
      if(!board.paused) board.piece.rotate(1);
    }

    e.preventDefault();
  });

  // pause + quit
  const pauseOverlay=document.getElementById("pauseOverlay");
  function openPause(){board.paused=true;pauseOverlay.classList.remove("hidden");}
  function closePause(){pauseOverlay.classList.add("hidden");board.paused=false;}

  document.getElementById("pauseBtn").addEventListener("click",openPause);
  document.getElementById("btnResume").addEventListener("click",closePause);
document.getElementById("btnQuit").addEventListener("click", async () => {
  await board.sendScore();   // save before reset
  board = new Board();       // new game instance
  closePause();
});


  // ====== LEADERBOARD (start overlay) ======
  const startOverlay = document.getElementById("startOverlay");
  const lbGlobal = document.getElementById("lbGlobal");
  const lbChat = document.getElementById("lbChat");

  function renderLB(listElem, data){
    listElem.innerHTML = "";
    if(!data || !data.length){
      listElem.textContent = "No scores yet.";
      return;
    }
    data.forEach((row, idx)=>{
      const div = document.createElement("div");
      div.className = "lb-item";
      const name = row.username || ("Player " + row.user_id);
      div.innerHTML = `<span>${idx+1}. ${name}</span><span>${row.best}</span>`;
      listElem.appendChild(div);
    });
  }

  async function loadLeaderboards(){
    try{
      const res = await fetch(`/games/tetris/leaderboard/?chat_id=${CHAT_ID||""}`);
      if(!res.ok) return;
      const data = await res.json();
      renderLB(lbGlobal, data.global || []);
      renderLB(lbChat, data.chat || []);
    }catch(e){console.error("leaderboard error",e);}
  }

  document.getElementById("btnStartGame").addEventListener("click",()=>{
    startOverlay.classList.add("hidden");
  });

  loadLeaderboards();
</script>
</body>
</html>
