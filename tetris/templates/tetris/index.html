<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tetris - Hir Games</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <style>
    :root {
      --bg-top: #2f2a8f;
      --bg-bottom: #050517;
      --shell: #dedede;
      --shell-border: #a0a0a0;
      --panel-dark: #2b2b2b;
      --panel-border: #707070;
      --label-text: #efefef;
      --screen-text: #e5e7eb;
      --accent-yellow: #facc15;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom));
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f9fafb;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;     /* page never scrolls */
      touch-action: none;   /* all touches go to JS */
    }

    .frame {
      width: 100%;
      max-width: 960px;
      padding: 6px;
      display: flex;
      justify-content: center;
    }

    .cabinet {
      /* side boxes smaller, center bigger */
      width: min(540px, 100vw - 10px);
      display: grid;
      grid-template-columns: 0.18fr 0.64fr 0.18fr;
      gap: 4px;
      padding: 8px;
      border-radius: 22px;
      background: linear-gradient(180deg, var(--shell) 0%, #f5f5f5 40%, #d0d0d0 100%);
      border: 4px solid var(--shell-border);
      box-shadow:
        0 24px 50px rgba(15, 23, 42, 0.85),
        inset 0 0 0 2px rgba(255, 255, 255, 0.7);
    }

    .side-column {
      display: flex;
      flex-direction: column;
      gap: 4px;
      justify-content: center;
    }

    .side-panel {
      min-width: 68px;              /* MUCH smaller */
      background: linear-gradient(180deg, #efefef 0%, #cfcfcf 100%);
      border-radius: 12px;
      padding: 4px 4px 6px;
      border: 2px solid var(--panel-border);
      box-shadow:
        inset 0 0 0 1px rgba(255, 255, 255, 0.7),
        0 3px 10px rgba(15, 23, 42, .4);
      text-align: center;
    }

    .side-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: .14em;
      color: #111827;
      margin-bottom: 2px;
    }

    .side-screen {
      background: var(--panel-dark);
      color: var(--label-text);
      border-radius: 9px;
      padding: 3px;
      min-height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: "Courier New", monospace;
      font-size: 10px;
      box-shadow:
        inset 0 0 8px rgba(0,0,0,.8),
        inset 0 0 0 1px rgba(148,163,184,.7);
    }

    .side-stat-col {
      display: flex;
      flex-direction: column;
      gap: 2px;
      width: 100%;
    }

    .side-stat {
      background: var(--panel-dark);
      border-radius: 7px;
      padding: 2px 4px;
      font-family: "Courier New", monospace;
      font-size: 10px;
      text-align: left;
      box-shadow:
        inset 0 0 6px rgba(0,0,0,.8),
        inset 0 0 0 1px rgba(148,163,184,.7);
    }

    .side-stat span {
      float: right;
      font-weight: 700;
      color: var(--accent-yellow);
    }

    .tower {
      background: linear-gradient(180deg, #f4f4f4 0%, #d0d0d0 60%, #bdbdbd 100%);
      border-radius: 20px;
      padding: 6px 5px 7px;
      border: 3px solid var(--shell-border);
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,.7),
        0 4px 10px rgba(15,23,42,.4);
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    .tower-top {
      background: #3f3f3f;
      border-radius: 12px 12px 0 0;
      padding: 3px 6px;
      border: 2px solid #1f2937;
      border-bottom: none;
      box-shadow:
        inset 0 0 0 1px rgba(156,163,175,.7),
        0 3px 8px rgba(0,0,0,.6);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .tower-title {
      font-family: "Courier New", monospace;
      text-transform: uppercase;
      letter-spacing: .18em;
      font-size: 10px;
      color: #f9fafb;
    }

    .tower-score-box {
      background: #111827;
      border-radius: 8px;
      padding: 1px 5px;
      font-family: "Courier New", monospace;
      font-size: 9px;
      color: var(--screen-text);
      box-shadow:
        inset 0 0 8px rgba(0,0,0,.9),
        inset 0 0 0 1px rgba(148,163,184,.7);
    }

    #scoreTop {
      font-weight: 700;
      color: var(--accent-yellow);
      margin-left: 3px;
    }

    .pause-button {
      width: 22px;
      height: 18px;
      border-radius: 7px;
      border: none;
      margin-left: 4px;
      background: linear-gradient(180deg, #d1d5db 0%, #6b7280 100%);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.8),
        0 3px 8px rgba(0,0,0,.6);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .pause-bars {
      width: 9px;
      height: 10px;
      display: flex;
      justify-content: space-between;
    }
    .pause-bars span {
      width: 3px;
      border-radius: 999px;
      background: #111827;
    }

    .tower-inner {
      background: #101010;
      border-radius: 0 0 14px 14px;
      border: 2px solid #1f2937;
      border-top: none;
      padding: 4px;
      box-shadow:
        inset 0 0 20px rgba(0,0,0,1),
        inset 0 0 0 1px rgba(75,85,99,.9);
    }

    .well-wrap {
      background: #000;
      border-radius: 7px;
      padding: 3px;
      border: 1px solid #374151;
      box-shadow:
        inset 0 0 10px rgba(0,0,0,.9);
    }

    #tetris {
      display: block;
      width: 100%;
      height: auto;
      background: #000;
      touch-action: none;
    }

    #nextCanvas, #holdCanvas {
      width: 54px;
      height: 44px;
    }

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.65);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    .hidden { display: none; }

    .modal {
      max-width: 320px;
      width: 90%;
      border-radius: 18px;
      background: linear-gradient(180deg, #4b4b4b 0%, #222 100%);
      border: 3px solid #111;
      box-shadow:
        0 18px 40px rgba(0,0,0,.9),
        inset 0 0 0 1px rgba(156,163,175,.8);
      padding: 12px 14px 14px;
      color: #f9fafb;
      text-align: center;
      font-size: 13px;
    }

    .modal-title {
      font-size: 15px;
      letter-spacing: .16em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .modal-hint {
      margin-top: 8px;
      font-size: 11px;
      text-align: left;
      line-height: 1.4;
      color: #e5e7eb;
    }

    .modal-hint strong {
      color: var(--accent-yellow);
    }

    .modal-btn-row {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 6px 16px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: .08em;
      cursor: pointer;
      box-shadow:
        0 4px 0 rgba(0,0,0,.9),
        0 10px 20px rgba(0,0,0,.9);
    }

    .btn-primary {
      background: linear-gradient(180deg, #34d399 0%, #059669 100%);
      color: #022c22;
    }

    .btn-danger {
      background: linear-gradient(180deg, #f97373 0%, #dc2626 100%);
      color: #111827;
    }
  </style>
</head>
<body>
<div class="frame">
  <div class="cabinet">
    <!-- LEFT SIDE -->
    <div class="side-column">
      <div class="side-panel">
        <div class="side-label">Hold</div>
        <div class="side-screen">
          <canvas id="holdCanvas" width="54" height="44"></canvas>
        </div>
      </div>
      <div class="side-panel">
        <div class="side-label">Stats</div>
        <div class="side-screen side-stat-col">
          <div class="side-stat">LEVEL <span id="level">1</span></div>
          <div class="side-stat">LINES <span id="lines">0</span></div>
        </div>
      </div>
    </div>

    <!-- CENTER -->
    <div class="tower">
      <div class="tower-top">
        <div class="tower-title">tetris</div>
        <div style="display:flex;align-items:center;gap:4px;">
          <div class="tower-score-box">
            SCORE <span id="scoreTop">0</span>
          </div>
          <button class="pause-button" id="pauseBtn">
            <div class="pause-bars"><span></span><span></span></div>
          </button>
        </div>
      </div>
      <div class="tower-inner">
        <div class="well-wrap">
          <canvas id="tetris"></canvas>
        </div>
      </div>
    </div>

    <!-- RIGHT SIDE -->
    <div class="side-column">
      <div class="side-panel">
        <div class="side-label">Next</div>
        <div class="side-screen">
          <canvas id="nextCanvas" width="54" height="44"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- PAUSE MENU (with controls hint) -->
<div class="overlay hidden" id="pauseOverlay">
  <div class="modal">
    <div class="modal-title">Paused</div>
    <div>Game is paused.</div>
    <div class="modal-btn-row">
      <button class="btn btn-primary" id="btnResume">Resume</button>
      <button class="btn btn-danger" id="btnQuit">Quit</button>
    </div>

    <div class="modal-hint">
      <strong>Controls:</strong><br>
      • Swipe left / right: move piece<br>
      • Swipe down slowly: soft drop<br>
      • Swipe down fast: hard drop<br>
      • Swipe up: Hold / swap piece<br>
      • Tap: rotate<br>
      • Keyboard: arrows + Space (desktop)
    </div>
  </div>
</div>

<script>
  const USER_ID = parseInt("{{ user_id|default:'0' }}") || 0;
  const CHAT_ID = parseInt("{{ chat_id|default:'0' }}") || 0;
  const USERNAME = "{{ username|default:'' }}";

  const canvas = document.getElementById("tetris");
  const ctx = canvas.getContext("2d");
  const nextCanvas = document.getElementById("nextCanvas");
  const nextCtx = nextCanvas.getContext("2d");
  const holdCanvas = document.getElementById("holdCanvas");
  const holdCtx = holdCanvas.getContext("2d");

  const COLS = 10;
  const ROWS = 20;
  let BLOCK = 10;

  function resizeCanvas() {
    const w = canvas.parentElement.clientWidth - 4;
    const width = Math.max(150, Math.min(w, 260));   // bigger playfield now
    const height = width * 2;
    canvas.width = width;
    canvas.height = height;
    BLOCK = canvas.width / COLS;
  }
  resizeCanvas();
  window.addEventListener("resize", () => {
    resizeCanvas();
    if (board) board.draw();
  });

  const COLORS = [
    null,
    "#00f0f0", // I
    "#0000f0", // J
    "#f0a000", // L
    "#f0f000", // O
    "#00f000", // S
    "#f00000", // Z
    "#a000f0", // T
  ];

  const SHAPES = {
    I: [[1,1,1,1]],
    J: [
      [2,0,0],
      [2,2,2],
    ],
    L: [
      [0,0,3],
      [3,3,3],
    ],
    O: [
      [4,4],
      [4,4],
    ],
    S: [
      [0,5,5],
      [5,5,0],
    ],
    Z: [
      [6,6,0],
      [0,6,6],
    ],
    T: [
      [0,7,0],
      [7,7,7],
    ],
  };
  const SHAPE_KEYS = Object.keys(SHAPES);

  function randomShapeMatrix() {
    const key = SHAPE_KEYS[(Math.random()*SHAPE_KEYS.length)|0];
    return SHAPES[key];
  }
  function cloneMatrix(m){return m.map(r=>[...r]);}
  function createMatrix(w,h){const m=[];while(h--)m.push(new Array(w).fill(0));return m;}

  function rotate(matrix, dir) {
    const res = matrix[0].map((_,i)=>matrix.map(r=>r[i]));
    return dir>0 ? res.map(r=>r.reverse()) : res.reverse();
  }

  class Piece {
    constructor(board, matrix){
      this.board = board;
      this.matrix = cloneMatrix(matrix);
      this.pos = {
        x: (COLS/2|0)-(this.matrix[0].length/2|0),
        y: 0,
      };
    }
    move(dx,dy){
      this.pos.x += dx;
      this.pos.y += dy;
      if (this.board.collides(this)){
        this.pos.x -= dx;
        this.pos.y -= dy;
        return false;
      }
      return true;
    }
    rotate(dir){
      const old = this.matrix;
      this.matrix = rotate(this.matrix, dir);
      const offs = [0,-1,1,-2,2];
      let i=0;
      while(this.board.collides(this)){
        this.pos.x += offs[i];
        i++;
        if (i>offs.length){
          this.matrix = old;
          return;
        }
      }
    }
  }

  class Board {
    constructor(){
      this.matrix = createMatrix(COLS, ROWS);
      this.nextShape = randomShapeMatrix();
      this.holdShape = null;
      this.holdUsed = false;
      this.spawnFromNext();
      this.score = 0;
      this.lines = 0;
      this.level = 1;
      this.dropInterval = 650;        // will get faster with level
      this.dropCounter = 0;
      this.lastTime = 0;
      this.gameOver = false;
      this.paused = false;
      this.updateHUD();
      this.drawNext();
      this.drawHold();
    }

    spawnFromNext(){
      this.piece = new Piece(this, this.nextShape);
      this.nextShape = randomShapeMatrix();
      this.drawNext();
    }

    hold(){
      if (this.paused || this.gameOver) return;
      if (this.holdUsed) return;  // only once per piece
      this.holdUsed = true;

      if (!this.holdShape){
        this.holdShape = cloneMatrix(this.piece.matrix);
        this.spawnFromNext();
      } else {
        const tmp = cloneMatrix(this.holdShape);
        this.holdShape = cloneMatrix(this.piece.matrix);
        this.piece = new Piece(this, tmp);
      }
      this.drawHold();
      if (this.collides(this.piece)){
        this.gameOver = true;
        this.sendScore();
      }
    }

    drawHold(){
      holdCtx.clearRect(0,0,holdCanvas.width,holdCanvas.height);
      if (!this.holdShape) return;
      const m = cloneMatrix(this.holdShape);
      const rows = m.length, cols = m[0].length;
      const cell = Math.min(
        (holdCanvas.width-6)/cols,
        (holdCanvas.height-6)/rows
      );
      const ox = (holdCanvas.width-cols*cell)/2;
      const oy = (holdCanvas.height-rows*cell)/2;
      for (let y=0;y<rows;y++){
        for (let x=0;x<cols;x++){
          const v=m[y][x]; if(!v)continue;
          const px=ox+x*cell, py=oy+y*cell;
          holdCtx.fillStyle = COLORS[v] || "#e5e7eb";
          holdCtx.fillRect(px+0.5,py+0.5,cell-1,cell-1);
          const g=holdCtx.createLinearGradient(px,py,px,py+cell);
          g.addColorStop(0,"rgba(255,255,255,0.4)");
          g.addColorStop(0.4,"rgba(255,255,255,0)");
          g.addColorStop(1,"rgba(0,0,0,0.5)");
          holdCtx.fillStyle=g;
          holdCtx.fillRect(px+0.5,py+0.5,cell-1,cell-1);
        }
      }
    }

    drawNext(){
      nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
      const m = cloneMatrix(this.nextShape);
      const rows = m.length, cols = m[0].length;
      const cell = Math.min(
        (nextCanvas.width-6)/cols,
        (nextCanvas.height-6)/rows
      );
      const ox = (nextCanvas.width-cols*cell)/2;
      const oy = (nextCanvas.height-rows*cell)/2;
      for (let y=0;y<rows;y++){
        for (let x=0;x<cols;x++){
          const v=m[y][x]; if(!v)continue;
          const px=ox+x*cell, py=oy+y*cell;
          nextCtx.fillStyle = COLORS[v] || "#e5e7eb";
          nextCtx.fillRect(px+0.5,py+0.5,cell-1,cell-1);
          const g=nextCtx.createLinearGradient(px,py,px,py+cell);
          g.addColorStop(0,"rgba(255,255,255,0.4)");
          g.addColorStop(0.4,"rgba(255,255,255,0)");
          g.addColorStop(1,"rgba(0,0,0,0.5)");
          nextCtx.fillStyle=g;
          nextCtx.fillRect(px+0.5,py+0.5,cell-1,cell-1);
        }
      }
    }

    updateHUD(){
      document.getElementById("scoreTop").innerText = this.score;
      document.getElementById("lines").innerText = this.lines;
      document.getElementById("level").innerText = this.level;
    }

    collides(piece){
      const m=piece.matrix, o=piece.pos;
      for (let y=0;y<m.length;y++){
        for (let x=0;x<m[y].length;x++){
          if (m[y][x]!==0){
            const nx=x+o.x, ny=y+o.y;
            if (nx<0||nx>=COLS||ny<0||ny>=ROWS) return true;
            if (this.matrix[ny][nx]!==0) return true;
          }
        }
      }
      return false;
    }

    merge(piece){
      piece.matrix.forEach((row,y)=>{
        row.forEach((v,x)=>{
          if(v) this.matrix[y+piece.pos.y][x+piece.pos.x]=v;
        });
      });
    }

    sweep(){
      let cleared=0;
      outer: for (let y=ROWS-1;y>=0;y--){
        for (let x=0;x<COLS;x++){
          if (!this.matrix[y][x]) continue outer;
        }
        const row=this.matrix.splice(y,1)[0].fill(0);
        this.matrix.unshift(row);
        y++; cleared++;
      }
      if(cleared){
        const pts=[0,40,100,300,1200][cleared]||0;
        this.score += pts*this.level;
        this.lines += cleared;
        this.level = 1 + Math.floor(this.lines/10);
        this.dropInterval = Math.max(120,650-(this.level-1)*40);  // auto speed-up
        this.updateHUD();
      }
    }

    hardDrop(){
      if (this.gameOver||this.paused) return;
      while(this.piece.move(0,1)){}
      this.lockPiece();
    }

    softDropStep(){
      if (this.gameOver||this.paused) return;
      if (!this.piece.move(0,1)) this.lockPiece();
    }

    lockPiece(){
      this.merge(this.piece);
      this.sweep();
      this.holdUsed = false;
      this.spawnFromNext();
      if (this.collides(this.piece)){
        this.gameOver = true;
        this.sendScore();
      }
    }

    update(dt){
      if (this.gameOver||this.paused) return;
      this.dropCounter += dt;
      if (this.dropCounter > this.dropInterval){
        this.softDropStep();
        this.dropCounter = 0;
      }
    }

    draw(){
      ctx.fillStyle="#000";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // grid
      ctx.strokeStyle="rgba(55,65,81,0.4)";
      ctx.lineWidth=0.5;
      for(let x=0;x<=COLS;x++){
        const px=x*BLOCK+0.5;
        ctx.beginPath();ctx.moveTo(px,0);ctx.lineTo(px,canvas.height);ctx.stroke();
      }
      for(let y=0;y<=ROWS;y++){
        const py=y*BLOCK+0.5;
        ctx.beginPath();ctx.moveTo(0,py);ctx.lineTo(canvas.width,py);ctx.stroke();
      }

      // board
      this.drawMatrix(this.matrix,{x:0,y:0});

      // ghost shadow
      const ghostPos={x:this.piece.pos.x,y:this.piece.pos.y};
      while(!this.collides({matrix:this.piece.matrix,pos:{x:ghostPos.x,y:ghostPos.y+1}})){
        ghostPos.y++;
      }
      this.drawMatrixGhost(this.piece.matrix, ghostPos);

      // active piece
      this.drawMatrix(this.piece.matrix,this.piece.pos);
    }

    drawMatrix(matrix,offset){
      matrix.forEach((row,y)=>{
        row.forEach((v,x)=>{
          if(v){
            const px=(x+offset.x)*BLOCK;
            const py=(y+offset.y)*BLOCK;
            ctx.fillStyle = COLORS[v] || "#e5e7eb";
            ctx.fillRect(px+0.5,py+0.5,BLOCK-1,BLOCK-1);
            const g=ctx.createLinearGradient(px,py,px,py+BLOCK);
            g.addColorStop(0,"rgba(255,255,255,0.4)");
            g.addColorStop(0.4,"rgba(255,255,255,0)");
            g.addColorStop(1,"rgba(0,0,0,0.5)");
            ctx.fillStyle=g;
            ctx.fillRect(px+0.5,py+0.5,BLOCK-1,BLOCK-1);
          }
        });
      });
    }

    drawMatrixGhost(matrix,offset){
      ctx.fillStyle="rgba(148,163,184,0.35)";
      matrix.forEach((row,y)=>{
        row.forEach((v,x)=>{
          if(v){
            const px=(x+offset.x)*BLOCK;
            const py=(y+offset.y)*BLOCK;
            ctx.fillRect(px+1,py+1,BLOCK-2,BLOCK-2);
          }
        });
      });
    }

    async sendScore(){
      if(!USER_ID||!CHAT_ID) return;
      try{
        await fetch("/tetris/submit-score/",{
          method:"POST",
          headers:{"Content-Type":"application/json"},
          body:JSON.stringify({
            user_id:USER_ID,
            chat_id:CHAT_ID,
            username:USERNAME,
            score:this.score,
          }),
        });
      }catch(e){console.error("submit-score error",e);}
    }
  }

  let board = new Board();

  function loop(time=0){
    const dt = time - board.lastTime;
    board.lastTime = time;
    board.update(dt);
    board.draw();
    requestAnimationFrame(loop);
  }
  loop();

  // Keyboard (desktop)
  document.addEventListener("keydown", e=>{
    if(board.gameOver||board.paused) return;
    if(e.key==="ArrowLeft") board.piece.move(-1,0);
    else if(e.key==="ArrowRight") board.piece.move(1,0);
    else if(e.key==="ArrowDown") board.softDropStep();
    else if(e.key==="ArrowUp") board.piece.rotate(1);
    else if(e.code==="Space"){e.preventDefault();board.hardDrop();}
    else if(e.key==="Escape") openPause();
  });

  // MOBILE TOUCH:
  // - drag left/right: smooth horizontal movement
  // - hold finger: continuous fast soft drop
  // - swipe down fast: hard drop
  // - swipe down slow: soft drop
  // - swipe up: hold / swap
  // - tap: rotate
  let touchActive=false,startX=0,startY=0,startTime=0,dragLastX=0,holdDropId=null;

  canvas.addEventListener("touchstart", e=>{
    if(board.gameOver) return;
    const t=e.touches[0];
    const r=canvas.getBoundingClientRect();
    startX=t.clientX-r.left;
    startY=t.clientY-r.top;
    dragLastX = startX;
    startTime=performance.now();
    touchActive=true;

    // continuous fast soft drop while finger is pressed
    holdDropId = setInterval(()=>{
      if(!board.gameOver && !board.paused){
        board.softDropStep();
      }
    },90);

    e.preventDefault();
  });

  canvas.addEventListener("touchmove", e=>{
    if(!touchActive || board.gameOver) return;
    const t=e.touches[0];
    const r=canvas.getBoundingClientRect();
    const x=t.clientX-r.left;
    const y=t.clientY-r.top;

    const dx = x - dragLastX;
    const stepX = BLOCK * 0.6;

    // smooth drag for horizontal movement
    if (dx > stepX) {
      let steps = Math.floor(dx / stepX);
      while (steps-- > 0) board.piece.move(1,0);
      dragLastX = x;
    } else if (dx < -stepX) {
      let steps = Math.floor(-dx / stepX);
      while (steps-- > 0) board.piece.move(-1,0);
      dragLastX = x;
    }

    e.preventDefault();
  });

  canvas.addEventListener("touchend", e=>{
    if(!touchActive || board.gameOver) return;
    touchActive=false;
    if (holdDropId){ clearInterval(holdDropId); holdDropId=null; }

    const r=canvas.getBoundingClientRect();
    const t=e.changedTouches[0];
    const x=t.clientX-r.left;
    const y=t.clientY-r.top;
    const dx=x-startX;
    const dy=y-startY;
    const dt=performance.now()-startTime;

    const absX=Math.abs(dx), absY=Math.abs(dy);

    if(absY>absX && dy<-22){
      // swipe up => hold
      board.hold();
    } else if(absY>absX && dy>18){
      const speed = dy/dt;
      if(speed>0.8 && dy>45) board.hardDrop();
      else board.softDropStep();
    } else if(absX>absY && absX>10){
      // horizontal swipe end: already moved on move, so nothing extra
    } else {
      // tap => rotate
      if(!board.paused) board.piece.rotate(1);
    }

    e.preventDefault();
  });

  // Pause menu
  const pauseOverlay=document.getElementById("pauseOverlay");
  function openPause(){board.paused=true;pauseOverlay.classList.remove("hidden");}
  function closePause(){pauseOverlay.classList.add("hidden");board.paused=false;}

  document.getElementById("pauseBtn").addEventListener("click",openPause);
  document.getElementById("btnResume").addEventListener("click",closePause);
  document.getElementById("btnQuit").addEventListener("click",()=>{
    board=new Board();
    closePause();
  });
</script>
</body>
</html>
