<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tetris - Hir Games</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <style>
    :root {
      --bg-top: #2f2a8f;
      --bg-bottom: #050517;
      --shell: #dedede;
      --shell-border: #a0a0a0;
      --panel-dark: #2b2b2b;
      --panel-border: #707070;
      --label-text: #efefef;
      --screen-bg: #111827;
      --screen-text: #e5e7eb;
      --accent-yellow: #facc15;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom));
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f9fafb;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow-x: auto; /* allow horizontal scroll on narrow phones */
    }

    .frame {
      width: 100%;
      max-width: 960px;
      padding: 10px;
      display: flex;
      justify-content: center;
    }

    .cabinet {
      /* fixed-ish width so side panels stay left/right */
      width: 680px;
      min-width: 680px;
      display: grid;
      grid-template-columns: 1fr minmax(230px, 260px) 1fr;
      gap: 10px;
      padding: 10px;
      border-radius: 24px;
      background: linear-gradient(180deg, var(--shell) 0%, #f5f5f5 40%, #d0d0d0 100%);
      border: 4px solid var(--shell-border);
      box-shadow:
        0 24px 50px rgba(15, 23, 42, 0.85),
        inset 0 0 0 2px rgba(255, 255, 255, 0.7);
    }

    .side-column {
      display: flex;
      flex-direction: column;
      gap: 10px;
      justify-content: center;
    }

    .side-panel {
      min-width: 120px;
      background: linear-gradient(180deg, #efefef 0%, #cfcfcf 100%);
      border-radius: 16px;
      padding: 6px 6px 10px;
      border: 2px solid var(--panel-border);
      box-shadow:
        inset 0 0 0 1px rgba(255, 255, 255, 0.7),
        0 3px 10px rgba(15, 23, 42, .4);
      text-align: center;
    }

    .side-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: .12em;
      color: #111827;
      margin-bottom: 4px;
    }

    .side-screen {
      background: var(--panel-dark);
      color: var(--label-text);
      border-radius: 12px;
      padding: 6px;
      min-height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: "Courier New", monospace;
      font-size: 13px;
      box-shadow:
        inset 0 0 10px rgba(0,0,0,.8),
        inset 0 0 0 1px rgba(148,163,184,.7);
    }

    .side-stat-col {
      display: flex;
      flex-direction: column;
      gap: 4px;
      width: 100%;
    }

    .side-stat {
      background: var(--panel-dark);
      border-radius: 8px;
      padding: 4px 6px;
      font-family: "Courier New", monospace;
      font-size: 11px;
      text-align: left;
      box-shadow:
        inset 0 0 8px rgba(0,0,0,.8),
        inset 0 0 0 1px rgba(148,163,184,.7);
    }

    .side-stat span {
      float: right;
      font-weight: 700;
      color: var(--accent-yellow);
    }

    /* Center tower ------------------------------------------------------- */

    .tower {
      background: linear-gradient(180deg, #f4f4f4 0%, #d0d0d0 60%, #bdbdbd 100%);
      border-radius: 24px;
      padding: 10px 8px 12px;
      border: 3px solid var(--shell-border);
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,.7),
        0 4px 10px rgba(15,23,42,.4);
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    .tower-top {
      background: #3f3f3f;
      border-radius: 14px 14px 0 0;
      padding: 6px 10px;
      border: 2px solid #1f2937;
      border-bottom: none;
      box-shadow:
        inset 0 0 0 1px rgba(156,163,175,.7),
        0 4px 10px rgba(0,0,0,.6);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .tower-title {
      font-family: "Courier New", monospace;
      text-transform: uppercase;
      letter-spacing: .2em;
      font-size: 12px;
      color: #f9fafb;
    }

    .tower-score-box {
      background: #111827;
      border-radius: 10px;
      padding: 3px 8px;
      font-family: "Courier New", monospace;
      font-size: 11px;
      color: var(--screen-text);
      box-shadow:
        inset 0 0 10px rgba(0,0,0,.9),
        inset 0 0 0 1px rgba(148,163,184,.7);
    }

    #scoreTop {
      font-weight: 700;
      color: var(--accent-yellow);
      margin-left: 4px;
    }

    .pause-button {
      width: 28px;
      height: 24px;
      border-radius: 8px;
      border: none;
      margin-left: 8px;
      background: linear-gradient(180deg, #d1d5db 0%, #6b7280 100%);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.8),
        0 4px 10px rgba(0,0,0,.6);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .pause-bars {
      width: 13px;
      height: 14px;
      display: flex;
      justify-content: space-between;
    }

    .pause-bars span {
      width: 4px;
      border-radius: 999px;
      background: #111827;
    }

    .tower-inner {
      background: #101010;
      border-radius: 0 0 18px 18px;
      border: 2px solid #1f2937;
      border-top: none;
      padding: 6px;
      box-shadow:
        inset 0 0 24px rgba(0,0,0,1),
        inset 0 0 0 1px rgba(75,85,99,.9);
    }

    .well-wrap {
      background: #000;
      border-radius: 8px;
      padding: 4px;
      border: 1px solid #374151;
      box-shadow:
        inset 0 0 12px rgba(0,0,0,.9);
    }

    #tetris {
      display: block;
      width: 100%;
      height: auto;
      background: #000;
    }

    #nextCanvas {
      width: 70px;
      height: 90px;
    }

    /* Overlays ----------------------------------------------------------- */

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.65);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    .hidden { display: none; }

    .modal {
      max-width: 340px;
      width: 90%;
      border-radius: 20px;
      background: linear-gradient(180deg, #4b4b4b 0%, #222 100%);
      border: 3px solid #111;
      box-shadow:
        0 18px 40px rgba(0,0,0,.9),
        inset 0 0 0 1px rgba(156,163,175,.8);
      padding: 14px 16px 18px;
      color: #f9fafb;
      text-align: center;
    }

    .modal-title {
      font-size: 16px;
      letter-spacing: .18em;
      text-transform: uppercase;
      margin-bottom: 12px;
    }

    .modal-body {
      font-size: 13px;
      color: #e5e7eb;
      margin-bottom: 12px;
    }

    .modal-body small {
      display: block;
      color: #9ca3af;
      margin-top: 6px;
      font-size: 11px;
    }

    .modal-btn-row {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 7px 18px;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: .08em;
      cursor: pointer;
      box-shadow:
        0 4px 0 rgba(0,0,0,.9),
        0 10px 20px rgba(0,0,0,.9);
    }

    .btn-primary {
      background: linear-gradient(180deg, #34d399 0%, #059669 100%);
      color: #022c22;
    }

    .btn-neutral {
      background: linear-gradient(180deg, #e5e7eb 0%, #9ca3af 100%);
      color: #111827;
    }

    .btn-danger {
      background: linear-gradient(180deg, #f97373 0%, #dc2626 100%);
      color: #111827;
    }

    .btn-small {
      padding: 5px 14px;
      font-size: 11px;
    }

    .slide-graphic {
      margin: 8px auto 6px;
      width: 80%;
      max-width: 220px;
      height: 180px;
      background: #000;
      border-radius: 8px;
      border: 2px solid #4b5563;
      position: relative;
      overflow: hidden;
    }

    .slide-graphic-grid {
      position: absolute;
      inset: 6px;
      background-image:
        linear-gradient(to right, rgba(55,65,81,.4) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(55,65,81,.4) 1px, transparent 1px);
      background-size: calc(100%/10) calc(100%/20);
    }

    .slide-caption {
      font-size: 12px;
      text-align: center;
      margin-top: 6px;
      color: #e5e7eb;
    }
    .slide-caption strong { color: var(--accent-yellow); }

    .options-group {
      text-align: left;
      font-size: 13px;
      margin-top: 4px;
    }

    .options-group label {
      display: block;
      margin-bottom: 4px;
      cursor: pointer;
    }

    .options-group input {
      margin-right: 6px;
    }
  </style>
</head>
<body>
<div class="frame">
  <div class="cabinet">
    <!-- LEFT SIDE -->
    <div class="side-column">
      <div class="side-panel">
        <div class="side-label">Hold</div>
        <div class="side-screen">
          <span style="font-size:11px;color:#6b7280;">(coming soon)</span>
        </div>
      </div>
      <div class="side-panel">
        <div class="side-label">Stats</div>
        <div class="side-screen side-stat-col">
          <div class="side-stat">LEVEL <span id="level">1</span></div>
          <div class="side-stat">LINES <span id="lines">0</span></div>
        </div>
      </div>
    </div>

    <!-- CENTER -->
    <div class="tower">
      <div class="tower-top">
        <div class="tower-title">tetris</div>
        <div style="display:flex;align-items:center;gap:6px;">
          <div class="tower-score-box">
            SCORE <span id="scoreTop">0</span>
          </div>
          <button class="pause-button" id="pauseBtn">
            <div class="pause-bars"><span></span><span></span></div>
          </button>
        </div>
      </div>
      <div class="tower-inner">
        <div class="well-wrap">
          <canvas id="tetris"></canvas>
        </div>
      </div>
    </div>

    <!-- RIGHT SIDE -->
    <div class="side-column">
      <div class="side-panel">
        <div class="side-label">Next</div>
        <div class="side-screen">
          <canvas id="nextCanvas" width="70" height="90"></canvas>
        </div>
      </div>
      <div class="side-panel">
        <div class="side-label">Hint</div>
        <div class="side-screen">
          <div style="font-size:11px;line-height:1.4;">
            Drag or swipe to move. Tap sides to rotate.
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- PAUSE MENU -->
<div class="overlay hidden" id="pauseOverlay">
  <div class="modal">
    <div class="modal-title">Paused</div>
    <div class="modal-body">Game is paused.</div>
    <div class="modal-btn-row">
      <button class="btn btn-primary" id="btnResume">Resume</button>
    </div>
    <div class="modal-btn-row">
      <button class="btn btn-neutral" id="btnOptions">Options</button>
      <button class="btn btn-neutral" id="btnHowTo">How to play</button>
    </div>
    <div class="modal-btn-row">
      <button class="btn btn-danger" id="btnQuit">Quit</button>
    </div>
  </div>
</div>

<!-- HOW TO PLAY -->
<div class="overlay hidden" id="howToOverlay">
  <div class="modal">
    <div class="modal-title" id="howToTitle">Smart control</div>
    <div class="modal-body" id="howToText">
      Drag your finger horizontally to choose a column.<br>
      Slide down to lower the piece. Fast downward swipe slams it down.
    </div>
    <div class="slide-graphic">
      <div class="slide-graphic-grid"></div>
    </div>
    <div class="slide-caption" id="howToCaption">
      <strong>Smart:</strong> slow drag = slow fall, fast drag down = hard drop.
    </div>
    <div class="modal-btn-row">
      <button class="btn btn-neutral btn-small" id="btnSlidePrev">&lt;</button>
      <button class="btn btn-primary btn-small" id="btnSlideDone">Done</button>
      <button class="btn btn-neutral btn-small" id="btnSlideNext">&gt;</button>
    </div>
  </div>
</div>

<!-- OPTIONS -->
<div class="overlay hidden" id="optionsOverlay">
  <div class="modal">
    <div class="modal-title">Options</div>
    <div class="modal-body">
      Choose touch control style (desktop uses keyboard).
      <div class="options-group">
        <label>
          <input type="radio" name="controlMode" value="smart">
          Smart control – drag to move, slow drag down to fall, fast drag down to hard drop.
        </label>
        <label>
          <input type="radio" name="controlMode" value="swipe">
          Swipe control – swipe to move/drop, tap sides to rotate.
        </label>
      </div>
      <small>Saved on this device.</small>
    </div>
    <div class="modal-btn-row">
      <button class="btn btn-primary" id="btnOptionsSave">Save</button>
      <button class="btn btn-neutral" id="btnOptionsCancel">Back</button>
    </div>
  </div>
</div>

<script>
  const USER_ID = parseInt("{{ user_id|default:'0' }}") || 0;
  const CHAT_ID = parseInt("{{ chat_id|default:'0' }}") || 0;
  const USERNAME = "{{ username|default:'' }}";

  const canvas = document.getElementById("tetris");
  const ctx = canvas.getContext("2d");
  const nextCanvas = document.getElementById("nextCanvas");
  const nextCtx = nextCanvas.getContext("2d");

  const COLS = 10;
  const ROWS = 20;
  let BLOCK = 10;

  function resizeCanvas() {
    const w = canvas.parentElement.clientWidth - 8;
    const width = Math.max(150, Math.min(w, 260));
    const height = width * 2;
    canvas.width = width;
    canvas.height = height;
    BLOCK = canvas.width / COLS;
  }
  resizeCanvas();
  window.addEventListener("resize", () => {
    resizeCanvas();
    if (board) board.draw();
  });

  const COLORS = [
    null,
    "#00f0f0", // I
    "#0000f0", // J
    "#f0a000", // L
    "#f0f000", // O
    "#00f000", // S
    "#f00000", // Z
    "#a000f0", // T
  ];

  const SHAPES = {
    I: [[1,1,1,1]],
    J: [
      [2,0,0],
      [2,2,2],
    ],
    L: [
      [0,0,3],
      [3,3,3],
    ],
    O: [
      [4,4],
      [4,4],
    ],
    S: [
      [0,5,5],
      [5,5,0],
    ],
    Z: [
      [6,6,0],
      [0,6,6],
    ],
    T: [
      [0,7,0],
      [7,7,7],
    ],
  };
  const SHAPE_KEYS = Object.keys(SHAPES);

  function randomShapeMatrix() {
    const key = SHAPE_KEYS[(Math.random() * SHAPE_KEYS.length) | 0];
    return SHAPES[key];
  }

  function cloneMatrix(m) {
    return m.map(row => [...row]);
  }

  function createMatrix(w, h) {
    const m = [];
    while (h--) m.push(new Array(w).fill(0));
    return m;
  }

  function rotate(matrix, dir) {
    const result = matrix[0].map((_, i) => matrix.map(r => r[i]));
    if (dir > 0) return result.map(row => row.reverse());
    return result.reverse();
  }

  class Piece {
    constructor(board, matrix) {
      this.board = board;
      this.matrix = cloneMatrix(matrix);
      this.pos = {
        x: (COLS / 2 | 0) - (this.matrix[0].length / 2 | 0),
        y: 0
      };
    }
    move(dx, dy) {
      this.pos.x += dx;
      this.pos.y += dy;
      if (this.board.collides(this)) {
        this.pos.x -= dx;
        this.pos.y -= dy;
        return false;
      }
      return true;
    }
    rotate(dir) {
      const old = this.matrix;
      this.matrix = rotate(this.matrix, dir);
      const offsets = [0,-1,1,-2,2];
      let i = 0;
      while (this.board.collides(this)) {
        this.pos.x += offsets[i];
        i++;
        if (i > offsets.length) {
          this.matrix = old;
          return;
        }
      }
    }
  }

  class Board {
    constructor() {
      this.matrix = createMatrix(COLS, ROWS);
      this.nextShape = randomShapeMatrix();
      this.spawnPiece();
      this.score = 0;
      this.lines = 0;
      this.level = 1;
      this.dropInterval = 650;
      this.dropCounter = 0;
      this.lastTime = 0;
      this.gameOver = false;
      this.paused = false;
      this.updateHUD();
      this.drawNext();
    }

    spawnPiece() {
      this.piece = new Piece(this, this.nextShape);
      this.nextShape = randomShapeMatrix();
      this.drawNext();
    }

    drawNext() {
      nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
      const matrix = cloneMatrix(this.nextShape);
      const rows = matrix.length;
      const cols = matrix[0].length;
      const cell = Math.min(
        (nextCanvas.width - 10) / cols,
        (nextCanvas.height - 10) / rows
      );
      const offsetX = (nextCanvas.width - cols * cell) / 2;
      const offsetY = (nextCanvas.height - rows * cell) / 2;
      for (let y=0;y<rows;y++){
        for (let x=0;x<cols;x++){
          const v = matrix[y][x];
          if (!v) continue;
          const px = offsetX + x * cell;
          const py = offsetY + y * cell;
          nextCtx.fillStyle = COLORS[v] || "#e5e7eb";
          nextCtx.fillRect(px+0.5,py+0.5,cell-1,cell-1);
          const g = nextCtx.createLinearGradient(px,py,px,py+cell);
          g.addColorStop(0,"rgba(255,255,255,0.4)");
          g.addColorStop(0.4,"rgba(255,255,255,0)");
          g.addColorStop(1,"rgba(0,0,0,0.5)");
          nextCtx.fillStyle = g;
          nextCtx.fillRect(px+0.5,py+0.5,cell-1,cell-1);
        }
      }
    }

    updateHUD() {
      document.getElementById("scoreTop").innerText = this.score;
      document.getElementById("lines").innerText = this.lines;
      document.getElementById("level").innerText = this.level;
    }

    collides(piece) {
      const m = piece.matrix;
      const o = piece.pos;
      for (let y=0;y<m.length;y++){
        for (let x=0;x<m[y].length;x++){
          if (m[y][x] !== 0) {
            const nx = x + o.x;
            const ny = y + o.y;
            if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) return true;
            if (this.matrix[ny][nx] !== 0) return true;
          }
        }
      }
      return false;
    }

    merge(piece) {
      piece.matrix.forEach((row,y)=>{
        row.forEach((v,x)=>{
          if (v!==0) this.matrix[y+piece.pos.y][x+piece.pos.x] = v;
        });
      });
    }

    sweep() {
      let cleared = 0;
      outer: for (let y=ROWS-1;y>=0;y--){
        for (let x=0;x<COLS;x++){
          if (this.matrix[y][x] === 0) continue outer;
        }
        const row = this.matrix.splice(y,1)[0].fill(0);
        this.matrix.unshift(row);
        y++;
        cleared++;
      }
      if (cleared > 0) {
        const points = [0,40,100,300,1200][cleared] || 0;
        this.score += points * this.level;
        this.lines += cleared;
        this.level = 1 + Math.floor(this.lines / 10);
        this.dropInterval = Math.max(120, 650 - (this.level - 1) * 40);
        this.updateHUD();
      }
    }

    hardDrop() {
      if (this.gameOver || this.paused) return;
      while (this.piece.move(0,1)) {}
      this.lockPiece();
    }

    softDropStep() {
      if (this.gameOver || this.paused) return;
      if (!this.piece.move(0,1)) {
        this.lockPiece();
      }
    }

    lockPiece() {
      this.merge(this.piece);
      this.sweep();
      this.spawnPiece();
      if (this.collides(this.piece)) {
        this.gameOver = true;
        this.sendScore();
      }
    }

    update(dt) {
      if (this.gameOver || this.paused) return;
      this.dropCounter += dt;
      if (this.dropCounter > this.dropInterval) {
        this.softDropStep();
        this.dropCounter = 0;
      }
    }

    draw() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.strokeStyle = "rgba(55,65,81,0.4)";
      ctx.lineWidth = 0.5;
      for (let x=0;x<=COLS;x++){
        const px = x*BLOCK + 0.5;
        ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,canvas.height); ctx.stroke();
      }
      for (let y=0;y<=ROWS;y++){
        const py = y*BLOCK + 0.5;
        ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(canvas.width,py); ctx.stroke();
      }

      this.drawMatrix(this.matrix,{x:0,y:0});
      this.drawMatrix(this.piece.matrix,this.piece.pos);
    }

    drawMatrix(matrix, offset) {
      matrix.forEach((row,y)=>{
        row.forEach((v,x)=>{
          if (v!==0) {
            const px = (x+offset.x)*BLOCK;
            const py = (y+offset.y)*BLOCK;
            ctx.fillStyle = COLORS[v] || "#e5e7eb";
            ctx.fillRect(px+0.5,py+0.5,BLOCK-1,BLOCK-1);
            const g = ctx.createLinearGradient(px,py,px,py+BLOCK);
            g.addColorStop(0,"rgba(255,255,255,0.4)");
            g.addColorStop(0.4,"rgba(255,255,255,0)");
            g.addColorStop(1,"rgba(0,0,0,0.5)");
            ctx.fillStyle = g;
            ctx.fillRect(px+0.5,py+0.5,BLOCK-1,BLOCK-1);
          }
        });
      });
    }

    async sendScore() {
      if (!USER_ID || !CHAT_ID) return;
      try {
        await fetch("/tetris/submit-score/", {
          method: "POST",
          headers: {"Content-Type": "application/json"},
          body: JSON.stringify({
            user_id: USER_ID,
            chat_id: CHAT_ID,
            username: USERNAME,
            score: this.score,
          }),
        });
      } catch (e) {
        console.error("submit-score error", e);
      }
    }
  }

  let board = new Board();

  function loop(time=0) {
    const dt = time - board.lastTime;
    board.lastTime = time;
    board.update(dt);
    board.draw();
    requestAnimationFrame(loop);
  }
  loop();

  // KEYBOARD CONTROLS ------------------------------------------------------
  document.addEventListener("keydown", e => {
    if (board.gameOver || board.paused) return;
    if (e.key === "ArrowLeft") {
      board.piece.move(-1,0);
    } else if (e.key === "ArrowRight") {
      board.piece.move(1,0);
    } else if (e.key === "ArrowDown") {
      board.softDropStep();
    } else if (e.key === "ArrowUp") {
      board.piece.rotate(1);
    } else if (e.code === "Space") {
      e.preventDefault();
      board.hardDrop();
    } else if (e.key === "Escape") {
      openPause();
    }
  });

  // TOUCH CONTROLS ---------------------------------------------------------
  let controlMode = localStorage.getItem("tetris_control_mode") || "smart";

  let touchActive = false;
  let touchStartX = 0, touchStartY = 0;
  let lastMoveX = 0, lastSoftDropY = 0;
  let touchStartTime = 0;

  function setControlMode(mode) {
    controlMode = mode;
    localStorage.setItem("tetris_control_mode", mode);
  }

  canvas.addEventListener("touchstart", e => {
    if (board.gameOver) return;
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = t.clientX - rect.left;
    const y = t.clientY - rect.top;
    touchActive = true;
    touchStartX = lastMoveX = x;
    touchStartY = y;
    lastSoftDropY = y;
    touchStartTime = performance.now();
  }, {passive: true});

  canvas.addEventListener("touchmove", e => {
    if (!touchActive || board.gameOver || board.paused) return;
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = t.clientX - rect.left;
    const y = t.clientY - rect.top;

    const dx = x - lastMoveX;
    const dy = y - touchStartY;

    // horizontal move (same for both modes)
    const stepX = BLOCK * 0.6;
    while (dx > stepX) {
      board.piece.move(1,0);
      lastMoveX += stepX;
    }
    while (dx < -stepX) {
      board.piece.move(-1,0);
      lastMoveX -= stepX;
    }

    if (controlMode === "smart") {
      // slow drag down => repeated soft-drop steps
      const diffY = y - lastSoftDropY;
      const stepY = BLOCK * 0.6;
      while (diffY > stepY) {
        board.softDropStep();
        lastSoftDropY += stepY;
      }
    } else {
      // swipe mode: we handle vertical in touchend
      // nothing here except horizontal
    }
  }, {passive: true});

  canvas.addEventListener("touchend", e => {
    if (!touchActive || board.gameOver) return;
    touchActive = false;

    const rect = canvas.getBoundingClientRect();
    const x = e.changedTouches[0].clientX - rect.left;
    const y = e.changedTouches[0].clientY - rect.top;
    const dx = x - touchStartX;
    const dy = y - touchStartY;
    const dt = performance.now() - touchStartTime;

    const absX = Math.abs(dx);
    const absY = Math.abs(dy);

    if (controlMode === "smart") {
      // Only downwards movement matters
      if (dy > 25) {
        const speed = dy / dt; // px per ms
        if (speed > 0.7) {
          // fast swipe down => hard drop
          board.hardDrop();
        } else {
          // slower drag: we already soft-dropped during move,
          // maybe add one more gentle step
          board.softDropStep();
        }
      }
      // simple tap does nothing in smart mode
    } else {
      // SWIPE MODE
      if (absX < 10 && absY < 10 && dt < 220) {
        // tap => rotate left/right
        if (x < canvas.width / 2) {
          board.piece.rotate(-1);
        } else {
          board.piece.rotate(1);
        }
      } else if (absY > absX && dy > 18) {
        const speed = dy / dt;
        if (speed > 0.7 && dy > 50) {
          board.hardDrop();
        } else {
          board.softDropStep();
        }
      }
      // horizontal swipes were already applied in move
    }
  }, {passive: true});

  // PAUSE & MENUS ----------------------------------------------------------
  const pauseOverlay = document.getElementById("pauseOverlay");
  const howToOverlay = document.getElementById("howToOverlay");
  const optionsOverlay = document.getElementById("optionsOverlay");

  function openPause() {
    board.paused = true;
    pauseOverlay.classList.remove("hidden");
  }
  function closePause() {
    pauseOverlay.classList.add("hidden");
    board.paused = false;
  }

  document.getElementById("pauseBtn").addEventListener("click", openPause);
  document.getElementById("btnResume").addEventListener("click", closePause);
  document.getElementById("btnQuit").addEventListener("click", () => {
    board = new Board();
    closePause();
  });

  // Options
  function openOptions() {
    pauseOverlay.classList.add("hidden");
    optionsOverlay.classList.remove("hidden");
    document.querySelectorAll('input[name="controlMode"]').forEach(r => {
      r.checked = (r.value === controlMode);
    });
  }
  function closeOptions() {
    optionsOverlay.classList.add("hidden");
    pauseOverlay.classList.remove("hidden");
  }

  document.getElementById("btnOptions").addEventListener("click", openOptions);
  document.getElementById("btnOptionsCancel").addEventListener("click", closeOptions);
  document.getElementById("btnOptionsSave").addEventListener("click", () => {
    const val = document.querySelector('input[name="controlMode"]:checked');
    if (val) setControlMode(val.value);
    closeOptions();
  });

  // How to play (two slides)
  let howToSlide = 0;
  const howToTitle = document.getElementById("howToTitle");
  const howToText = document.getElementById("howToText");
  const howToCaption = document.getElementById("howToCaption");

  function renderHowToSlide() {
    if (howToSlide === 0) {
      howToTitle.textContent = "Smart control";
      howToText.innerHTML =
        "Drag your finger horizontally and down.<br>" +
        "Slow drag down makes the piece fall step by step.<br>" +
        "Fast drag down slams it to the bottom.";
      howToCaption.innerHTML =
        "<strong>Smart:</strong> slow = soft, fast = hard drop.";
    } else {
      howToTitle.textContent = "Swipe control";
      howToText.innerHTML =
        "Swipe left / right to move the piece.<br>" +
        "Tap left or right side to rotate.<br>" +
        "Swipe down to drop, fast swipe down = hard drop.";
      howToCaption.innerHTML =
        "<strong>Swipe:</strong> move with swipes, rotate with taps.";
    }
  }

  function openHowTo() {
    pauseOverlay.classList.add("hidden");
    howToOverlay.classList.remove("hidden");
    howToSlide = 0;
    renderHowToSlide();
  }

  function closeHowTo() {
    howToOverlay.classList.add("hidden");
    pauseOverlay.classList.remove("hidden");
  }

  document.getElementById("btnHowTo").addEventListener("click", openHowTo);
  document.getElementById("btnSlideDone").addEventListener("click", closeHowTo);
  document.getElementById("btnSlidePrev").addEventListener("click", () => {
    howToSlide = (howToSlide + 1) % 2;
    renderHowToSlide();
  });
  document.getElementById("btnSlideNext").addEventListener("click", () => {
    howToSlide = (howToSlide + 1) % 2;
    renderHowToSlide();
  });

  // initialize control mode once
  setControlMode(controlMode);
</script>
</body>
</html>
